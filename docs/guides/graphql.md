# GraphQL API Guide

This document describes the GraphQL API generated by Rail Django and provides
example queries and mutations.

## Endpoints

- `POST /graphql/<schema_name>/` (multi-schema)
- `GET /schemas/` (JSON list of registered schemas)

Note: GraphiQL is controlled by `schema_settings.enable_graphiql`.

## Persisted queries (APQ)

Rail Django supports APQ-style persisted queries when enabled via
`persisted_query_settings`. Clients send a `sha256Hash` inside
`extensions.persistedQuery` and can omit the query body after the hash is
registered. If `enforce_allowlist` is enabled, unknown hashes are rejected.
When `enforce_allowlist` is false, unknown hashes return `PERSISTED_QUERY_NOT_FOUND`
so clients can register them when `allow_unregistered` is enabled. See
`../extensions/persisted-queries.md` and `../reference/configuration.md` for setup details.

## Field naming

By default `auto_camelcase` is false, so field names are snake_case. If you set
`schema_settings.auto_camelcase = True`, Graphene will expose camelCase names.
Examples below use the default snake_case output.

## Authentication

Rail Django supports JWT auth. Tokens can be passed via header or (optionally)
HTTP-only cookies.

Header format:

```
Authorization: Bearer <jwt>
```

Login mutation (when security mutations are enabled):

```graphql
mutation Login($username: String!, $password: String!) {
  login(username: $username, password: $password) {
    ok
    token
    refresh_token
    expires_at
    errors
    user {
      id
      username
      email
    }
  }
}
```

Refresh token:

```graphql
mutation Refresh($token: String!) {
  refresh_token(refresh_token: $token) {
    ok
    token
    refresh_token
    expires_at
    errors
  }
}
```

Current user:

```graphql
query Me {
  me {
    id
    username
    permissions
  }
}
```

## Query naming conventions

For each Django model, Rail Django generates a set of root fields:

- Single: `<model>` (example: `user(id: ID!)`)
- List: `<model>s` (example: `users`)
- Paginated: `<model>s_pages` (example: `users_pages`)
- Grouping: `<model>s_groups` (example: `users_groups`)

If a custom manager is exposed, the name becomes `<model>__<manager>` for the
single field and `<model>s__<manager>` for list queries.

## GraphQLMeta configuration

GraphQLMeta is the per-model configuration class in `rail_django/core/meta.py`.
It controls field exposure, filtering, ordering, and access guards for the
auto-generated schema. Define it as an inner class on your model:

```python
from django.db import models
from rail_django.core.meta import GraphQLMeta as GraphQLMetaConfig


class Customer(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()
    status = models.CharField(max_length=20)
    created_at = models.DateTimeField(auto_now_add=True)

    class GraphQLMeta(GraphQLMetaConfig):
        fields = GraphQLMetaConfig.Fields(
            exclude=["internal_notes"],
            read_only=["status"],
        )
        filtering = GraphQLMetaConfig.Filtering(
            quick=["name", "email"],
            fields={
                "status": GraphQLMetaConfig.FilterField(
                    lookups=["exact", "in"],
                    choices=["active", "paused"],
                ),
            },
        )
        ordering = GraphQLMetaConfig.Ordering(default=["-created_at"])
```

For detailed usage and access control examples, see the [GraphQLMeta guide](../reference/meta.md).

## Single item query

```graphql
query GetUser {
  user(id: "1") {
    id
    username
    email
  }
}
```

## List query with filters and ordering

The list field accepts `filters`, `order_by`, and optional pagination fields
`offset` and `limit` when enabled.

```graphql
query ListUsers($filters: UserComplexFilter!) {
  users(
    filters: $filters
    order_by: ["-date_joined"]
    offset: 0
    limit: 20
  ) {
    id
    username
    date_joined
  }
}
```

Variables example (complex filter input supports AND/OR/NOT):

```json
{
  "filters": {
    "AND": [
      {"is_active__exact": true},
      {"username__icontains": "admin"}
    ],
    "OR": [
      {"email__icontains": "example.com"},
      {"email__icontains": "corp.com"}
    ],
    "NOT": {"last_login__isnull": true}
  }
}
```

Common filter operators include:
- `__exact`, `__icontains`, `__startswith`, `__endswith`
- `__in`, `__isnull`, `__range`, `__gt`, `__gte`, `__lt`, `__lte`
- Date helpers: `<field>_today`, `<field>_this_week`, `<field>_past_month`

The filter set is generated from model fields and GraphQLMeta overrides.

## Paginated query

Paginated fields return `items` and `page_info`.

```graphql
query PagedUsers {
  users_pages(page: 1, per_page: 25, order_by: ["-id"]) {
    items {
      id
      username
    }
    page_info {
      total_count
      page_count
      current_page
      per_page
      has_next_page
      has_previous_page
    }
  }
}
```

## Grouping query

Grouping returns buckets with counts.

```graphql
query GroupByStatus {
  users_groups(group_by: "is_active", order_by: "count", limit: 10) {
    key
    label
    count
  }
}
```

## Mutations (create, update, delete)

Auto-generated mutation names are snake_case by default:

- `create_<model>`
- `update_<model>`
- `delete_<model>`
- `bulk_create_<model>` (if enabled)

Example create mutation:

```graphql
mutation CreateUser($input: UserCreateInput!) {
  create_user(input: $input) {
    ok
    object {
      id
      username
      email
    }
    errors {
      message
      field
    }
  }
}
```

Example update mutation:

```graphql
mutation UpdateUser($id: ID!, $input: UserUpdateInput!) {
  update_user(id: $id, input: $input) {
    ok
    object {
      id
      username
    }
    errors {
      message
      field
    }
  }
}
```

Note: `id` is required as the top-level mutation argument. `input.id` is optional
and kept for backwards compatibility.

## Model metadata

If `schema_settings.show_metadata` is enabled, GraphQL exposes metadata queries
to help frontends build forms and tables. Metadata requires an authenticated
user and returns a `metadataVersion` field so clients can avoid refetching
unchanged metadata. See `../extensions/metadata.md` for details.

## Error handling

GraphQL errors use standard GraphQL error payloads. In production, configure
`error_handling` settings to avoid leaking internal details.

## Notes for multi-schema

- Each schema can override settings via `RAIL_DJANGO_GRAPHQL_SCHEMAS` or the
  schema registry.
- If `authentication_required` is enabled for a schema, requests must include
  a valid JWT.
