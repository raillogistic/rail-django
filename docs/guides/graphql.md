# GraphQL API Guide

This document describes the GraphQL API generated by Rail Django and provides
example queries and mutations.

## Endpoints

- `POST /graphql/<schema_name>/` (multi-schema)
- `GET /schemas/` (JSON list of registered schemas)

Note: GraphiQL is controlled by `schema_settings.enable_graphiql`.

## Persisted queries (APQ)

Rail Django supports APQ-style persisted queries when enabled via
`persisted_query_settings`. Clients send a `sha256Hash` inside
`extensions.persistedQuery` and can omit the query body after the hash is
registered. If `enforce_allowlist` is enabled, unknown hashes are rejected.
When `enforce_allowlist` is false, unknown hashes return `PERSISTED_QUERY_NOT_FOUND`
so clients can register them when `allow_unregistered` is enabled. See
`../extensions/persisted-queries.md` and `../reference/configuration.md` for setup details.

## Field naming

By default `auto_camelcase` is true, so field names are camelCase. If you set
`schema_settings.auto_camelcase = False`, Graphene will expose snake_case names.
Examples below use the default camelCase output.

## Authentication

Rail Django supports JWT auth. Tokens can be passed via header or (optionally)
HTTP-only cookies.

Header format:

```
Authorization: Bearer <jwt>
```

Login mutation (when security mutations are enabled):

```graphql
mutation Login($username: String!, $password: String!) {
  login(username: $username, password: $password) {
    ok
    token
    refreshToken
    expiresAt
    errors
    user {
      id
      username
      email
    }
  }
}
```

Refresh token:

```graphql
mutation Refresh($token: String!) {
  refreshToken(refreshToken: $token) {
    ok
    token
    refreshToken
    expiresAt
    errors
  }
}
```

Current user:

```graphql
query Me {
  me {
    id
    username
    permissions
  }
}
```

## Query naming conventions

For each Django model, Rail Django generates a set of root fields:

- Single: `<model>` (example: `user(id: ID!)`)
- List: `<model>s` (example: `users`)
- Paginated: `<model>sPages` (example: `usersPages`)
- Grouping: `<model>sGroups` (example: `usersGroups`)

If a custom manager is exposed, the name becomes `<model>__<manager>` for the
single field and `<model>s__<manager>` for list queries.

## GraphQLMeta configuration

GraphQLMeta is the per-model configuration class in `rail_django/core/meta.py`.
It controls field exposure, filtering, ordering, and access guards for the
auto-generated schema. Define it as an inner class on your model:

```python
from django.db import models
from rail_django.core.meta import GraphQLMeta as GraphQLMetaConfig


class Customer(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()
    status = models.CharField(max_length=20)
    created_at = models.DateTimeField(auto_now_add=True)

    class GraphQLMeta(GraphQLMetaConfig):
        fields = GraphQLMetaConfig.Fields(
            exclude=["internal_notes"],
            read_only=["status"],
        )
        filtering = GraphQLMetaConfig.Filtering(
            quick=["name", "email"],
            fields={
                "status": GraphQLMetaConfig.FilterField(
                    lookups=["eq", "in"],
                    choices=["active", "paused"],
                ),
            },
        )
        ordering = GraphQLMetaConfig.Ordering(default=["-created_at"])
```

For detailed usage and access control examples, see the [GraphQLMeta guide](../reference/meta.md).

## Single item query

```graphql
query GetUser {
  user(id: "1") {
    id
    username
    email
  }
}
```

## List query with filters and ordering

The list field accepts `where`, `orderBy`, and optional pagination fields
`offset` and `limit` when enabled.

```graphql
query ListUsers($where: UserWhereInput!) {
  users(
    where: $where
    orderBy: ["-dateJoined"]
    offset: 0
    limit: 20
  ) {
    id
    username
    dateJoined
  }
}
```

Variables example (nested filter input supports AND/OR/NOT):

```json
{
  "where": {
    "AND": [
      {"isActive": {"eq": true}},
      {"username": {"icontains": "admin"}}
    ],
    "OR": [
      {"email": {"icontains": "example.com"}},
      {"email": {"icontains": "corp.com"}}
    ],
    "NOT": {"lastLogin": {"isNull": true}}
  }
}
```

Common filter operators include:
- `eq`, `neq`, `icontains`, `startsWith`, `endsWith`
- `in`, `notIn`, `isNull`, `between`, `gt`, `gte`, `lt`, `lte`
- Date helpers: `today`, `thisWeek`, `pastMonth`

If you enable Relay or legacy flat filters, you can also use the `filters`
argument with django-filter lookups like `status__in` or `created_at__gte`.

For advanced filtering details, see the [Filtering Guide](./filtering.md).

## Paginated query

Paginated fields return `items` and `page_info`.

```graphql
query PagedUsers {
  usersPages(page: 1, perPage: 25, orderBy: ["-id"]) {
    items {
      id
      username
    }
    pageInfo {
      totalCount
      pageCount
      currentPage
      perPage
      hasNextPage
      hasPreviousPage
    }
  }
}
```

## Grouping query

Grouping returns buckets with counts.

```graphql
query GroupByStatus {
  usersGroups(groupBy: "isActive", orderBy: "count", limit: 10) {
    key
    label
    count
  }
}
```

## Mutations (create, update, delete)

Auto-generated mutation names are camelCase by default:

- `createModel`
- `updateModel`
- `deleteModel`
- `bulkCreateModel` (if enabled)

Example create mutation:

```graphql
mutation CreateUser($input: UserCreateInput!) {
  createUser(input: $input) {
    ok
    object {
      id
      username
      email
    }
    errors {
      message
      field
    }
  }
}
```

Example update mutation:

```graphql
mutation UpdateUser($id: ID!, $input: UserUpdateInput!) {
  updateUser(id: $id, input: $input) {
    ok
    object {
      id
      username
    }
    errors {
      message
      field
    }
  }
}
```

Note: `id` is required as the top-level mutation argument. `input.id` is optional
and kept for backwards compatibility.

## Model metadata

If `schema_settings.show_metadata` is enabled, GraphQL exposes metadata queries
to help frontends build forms and tables. Metadata requires an authenticated
user and returns a `metadataVersion` field so clients can avoid refetching
unchanged metadata. See `../extensions/metadata.md` for details.

## Error handling

GraphQL errors use standard GraphQL error payloads. In production, configure
`error_handling` settings to avoid leaking internal details.

## Notes for multi-schema

- Each schema can override settings via `RAIL_DJANGO_GRAPHQL_SCHEMAS` or the
  schema registry.
- If `authentication_required` is enabled for a schema, requests must include
  a valid JWT.
