"""
GraphQL Subscription Consumer implementing graphql-transport-ws protocol.
"""

import logging
import asyncio
from typing import Any, Dict, Optional, List

from channels.generic.websocket import AsyncJsonWebsocketConsumer
from django.conf import settings
from graphql import GraphQLError
from graphql.error.graphql_error import format_error

from rail_django.core.schema import get_schema
from .protocol import (
    CONNECTION_ACK,
    CONNECTION_INIT,
    NEXT,
    COMPLETE,
    ERROR,
    PING,
    PONG,
    SUBSCRIBE,
    GRAPHQL_TRANSPORT_WS_PROTOCOL,
)

logger = logging.getLogger(__name__)


class RailGraphqlWsConsumer(AsyncJsonWebsocketConsumer):
    """
    Consumer for GraphQL subscriptions over WebSocket.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.schema_name = "default"
        self._subscriptions: Dict[str, List[str]] = {}  # operation_id -> list of groups

    async def connect(self):
        self.schema_name = self.scope.get("url_route", {}).get("kwargs", {}).get("schema_name", "default")
        try:
            self.schema = get_schema(self.schema_name)
        except Exception:
            await self.close(code=4400)  # Schema not found
            return

        await self.accept(subprotocol=GRAPHQL_TRANSPORT_WS_PROTOCOL)

    async def disconnect(self, code):
        for op_id in list(self._subscriptions.keys()):
            await self.unsubscribe(op_id)

    async def receive_json(self, content: Dict[str, Any], **kwargs):
        msg_type = content.get("type")
        
        if msg_type == CONNECTION_INIT:
            await self.send_json({"type": CONNECTION_ACK})
        elif msg_type == PING:
            await self.send_json({"type": PONG})
        elif msg_type == SUBSCRIBE:
            await self.handle_subscribe(content)
        elif msg_type == COMPLETE:
            await self.unsubscribe(content.get("id"))
        else:
            # Handle other types or ignore
            pass

    async def handle_subscribe(self, payload: Dict[str, Any]):
        op_id = payload.get("id")
        if not op_id:
            return

        params = payload.get("payload", {})
        query = params.get("query")
        variables = params.get("variables")
        operation_name = params.get("operationName")

        if not query:
            return

        # Execute the subscription "query" to get the groups
        # We use a custom execution context to signal this is a subscription init
        context = {
            "user": self.scope.get("user"),
            "schema_name": self.schema_name,
            "is_subscription": True,
        }

        try:
            # Execute the query. The resolvers for subscriptions in Rail Django 
            # (generated by SubscriptionGenerator) return a list of channel groups.
            result = await self.schema.execute_async(
                query,
                variable_values=variables,
                operation_name=operation_name,
                context_value=context,
            )

            if result.errors:
                await self.send_json({
                    "type": ERROR,
                    "id": op_id,
                    "payload": [format_error(e) for e in result.errors],
                })
                return

            # The result.data should contain the group names
            # Structure: {"orderCreated": ["rail_sub:default:order:created"]}
            groups = []
            if result.data:
                for field_data in result.data.values():
                    if isinstance(field_data, list):
                        groups.extend(field_data)
                    elif isinstance(field_data, str):
                        groups.append(field_data)

            if not groups:
                # No groups returned, maybe immediate completion?
                # For now, just keep open but inactive?
                pass

            # Subscribe to groups
            for group in groups:
                await self.channel_layer.group_add(group, self.channel_name)
            
            # Store the original query info to re-execute on events
            self._subscriptions[op_id] = {
                "groups": groups,
                "query": query,
                "variables": variables,
                "operation_name": operation_name,
            }

        except Exception as e:
            logger.error(f"Subscription error: {e}")
            await self.send_json({
                "type": ERROR,
                "id": op_id,
                "payload": [{"message": str(e)}],
            })

    async def unsubscribe(self, op_id: str):
        if op_id in self._subscriptions:
            data = self._subscriptions.pop(op_id)
            groups = data.get("groups", [])
            for group in groups:
                await self.channel_layer.group_discard(group, self.channel_name)

    async def graphql_subscription_broadcast(self, event: Dict[str, Any]):
        """
        Handler for messages sent via group_send.
        Event structure: {"type": "graphql.subscription.broadcast", "payload": ..., "group": ...}
        """
        group = event.get("group")
        payload = event.get("payload")

        # Find which operations are listening to this group
        for op_id, data in self._subscriptions.items():
            if group in data.get("groups", []):
                # We found a matching subscription.
                # In a full implementation, we should re-execute the query with the payload as root.
                # However, Rail Django's generated subscriptions expect to just return the payload 
                # processed by the 'publish' method.
                
                # We need to re-run the execute to hit the 'publish' resolver logic (filtering, masking)
                # We pass the payload as root_value.
                
                query = data["query"]
                variables = data["variables"]
                operation_name = data["operation_name"]
                
                context = {
                    "user": self.scope.get("user"),
                    "schema_name": self.schema_name,
                    "is_publication": True,
                }

                try:
                    result = await self.schema.execute_async(
                        query,
                        variable_values=variables,
                        operation_name=operation_name,
                        context_value=context,
                        root_value=payload, # Pass the event payload as root
                    )

                    if result.errors:
                        await self.send_json({
                            "type": ERROR,
                            "id": op_id,
                            "payload": [format_error(e) for e in result.errors],
                        })
                    elif result.data:
                        # If the resolver returns None (filtered out), result.data might have nulls
                        # We need to check if the specific field is null/SKIP
                        
                        # Simplified check: send data
                        await self.send_json({
                            "type": NEXT,
                            "id": op_id,
                            "payload": {"data": result.data},
                        })

                except Exception as e:
                    logger.error(f"Error processing subscription event: {e}")


def get_subscription_consumer(schema_name: str = "default") -> Any:
    return RailGraphqlWsConsumer