"""
Generated-form mutation helper primitives.

This module intentionally avoids defining GraphQL mutation fields because model
CRUD mutations are generated by the core schema builder. The helpers here are
shared by generated-form adapter workflows and tests.
"""

from __future__ import annotations

from typing import Any, Callable, Iterable

from django.db import transaction
from graphql import GraphQLError

from ..config import DEFAULT_FORM_ERROR_KEY
from ..normalization.error_normalizer import normalize_bulk_errors, normalize_mutation_errors
from ..normalization.input_normalizer import enforce_primary_key_only_update_target
from ..utils.authorization import ensure_generated_mutation_authorized


def detect_stale_update_conflict(
    *,
    current_version: Any,
    submitted_version: Any,
) -> bool:
    if submitted_version in (None, ""):
        return False
    return str(current_version) != str(submitted_version)


def build_conflict_outcome(
    *,
    message: str = "The record is stale. Refresh and retry.",
    field: str = DEFAULT_FORM_ERROR_KEY,
) -> dict[str, Any]:
    return {
        "ok": False,
        "errors": normalize_mutation_errors(
            [{"field": field, "message": message, "code": "CONFLICT"}],
            source="OPERATION",
        ),
        "conflict": True,
        "form_error_key": DEFAULT_FORM_ERROR_KEY,
    }


def build_success_outcome() -> dict[str, Any]:
    return {
        "ok": True,
        "errors": [],
        "conflict": False,
        "form_error_key": DEFAULT_FORM_ERROR_KEY,
    }


def validate_update_target(target: dict[str, Any]) -> str:
    return enforce_primary_key_only_update_target(target)


def enforce_mutation_authorization(
    info: Any,
    model: Any,
    *,
    operation: str,
    instance: Any | None = None,
) -> None:
    ensure_generated_mutation_authorized(
        info,
        model,
        operation=operation,
        instance=instance,
    )


def execute_atomic_bulk(
    *,
    items: Iterable[dict[str, Any]],
    mutator: Callable[[dict[str, Any], int], Any],
) -> dict[str, Any]:
    errors: list[dict[str, Any]] = []
    results: list[Any] = []

    with transaction.atomic():
        for row_index, item in enumerate(items or []):
            try:
                results.append(mutator(item, row_index))
            except Exception as exc:
                transaction.set_rollback(True)
                errors.append(
                    {
                        "row_index": row_index,
                        "field": DEFAULT_FORM_ERROR_KEY,
                        "message": str(exc),
                        "code": "BULK_ROW_ERROR",
                    }
                )
                break

    if errors:
        return {
            "ok": False,
            "objects": [],
            "errors": normalize_bulk_errors(errors, source="OPERATION"),
            "conflict": False,
            "form_error_key": DEFAULT_FORM_ERROR_KEY,
        }

    return {
        "ok": True,
        "objects": results,
        "errors": [],
        "conflict": False,
        "form_error_key": DEFAULT_FORM_ERROR_KEY,
    }


def map_exception_to_generated_outcome(exc: Exception) -> dict[str, Any]:
    if isinstance(exc, GraphQLError):
        errors = normalize_mutation_errors(
            [{"field": DEFAULT_FORM_ERROR_KEY, "message": str(exc), "code": "GRAPHQL"}],
            source="EXECUTION",
        )
    else:
        errors = normalize_mutation_errors(
            [
                {
                    "field": DEFAULT_FORM_ERROR_KEY,
                    "message": str(exc),
                    "code": "UNEXPECTED",
                }
            ],
            source="TRANSPORT",
        )
    return {
        "ok": False,
        "errors": errors,
        "conflict": False,
        "form_error_key": DEFAULT_FORM_ERROR_KEY,
    }
